<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Importar PDF subrayado → Quiz (modo oscuro)</title>

<!-- pdf.js (worker + lib) desde CDN -->
<script src="https://unpkg.com/pdfjs-dist@3.8.162/build/pdf.min.js"></script>

<style>
  :root{
    --bg:#071021; --panel:#0b1624; --muted:#a9b7c0; --accent:#06b6d4;
    --correct:#15803d; --wrong:#dc2626; --glass: rgba(255,255,255,0.02);
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#04121b,#071021);color:#e6f7f8}
  .wrap{max-width:1100px;margin:18px auto;padding:14px}
  header{display:flex;gap:12px;align-items:center}
  header h1{margin:0;font-size:20px}
  .card{background:linear-gradient(180deg,var(--panel),#081422);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.04)}
  .grid{display:grid;grid-template-columns:1fr 420px;gap:12px;margin-top:12px}
  @media(max-width:960px){ .grid{grid-template-columns:1fr} }
  input[type=file]{color:var(--muted)}
  textarea{width:100%;min-height:120px;background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:var(--muted)}
  button{background:linear-gradient(90deg,var(--accent),#4ddce7);border:none;padding:8px 12px;border-radius:9px;color:#042022;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .list{max-height:520px;overflow:auto;padding:8px;display:flex;flex-direction:column;gap:8px}
  .qitem{padding:10px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));}
  .options{display:flex;flex-direction:column;gap:6px;margin-top:8px}
  label.opt{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px;border:1px solid transparent;cursor:pointer}
  .opt-correct{border-color:rgba(21,128,61,0.25);background:rgba(21,128,61,0.06)}
  .opt-wrong{border-color:rgba(220,38,38,0.25);background:rgba(220,38,38,0.06)}
  .meta{font-size:13px;color:var(--muted)}
  .hint{color:var(--muted);font-size:13px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Importar PDF subrayado → Quiz</h1>
      <div class="hint">Sube un PDF con texto seleccionable y subrayados (anotaciones). El sistema intentará detectar la opción subrayada como correcta.</div>
    </div>
    <div style="margin-left:auto;display:flex;gap:8px">
      <button id="exportBtn" class="ghost">Exportar JSON</button>
      <button id="clearBtn" class="ghost">Borrar todo</button>
    </div>
  </header>

  <div class="grid">
    <section>
      <div class="card">
        <div style="display:flex;gap:8px;align-items:center">
          <input id="pdfFile" type="file" accept="application/pdf">
          <button id="analyzeBtn">Analizar PDF</button>
          <button id="previewBtn" class="ghost">Vista previa texto</button>
        </div>
        <div style="margin-top:8px" class="hint">Asegúrate de que el PDF tenga texto (no imagen). Si tu PDF proviene de Notas, exporta la nota como PDF desde la app Notas.</div>
      </div>

      <div class="card" style="margin-top:12px">
        <strong>Salida / Mensajes</strong>
        <div id="log" style="margin-top:8px;color:var(--muted);font-size:13px">Sin analizar.</div>
      </div>

      <div class="card" style="margin-top:12px">
        <strong>Texto extraído (útil para verificar)</strong>
        <textarea id="textPreview" readonly placeholder="Después de analizar verás el texto extraído aquí..."></textarea>
      </div>
    </section>

    <aside>
      <div class="card" style="display:flex;flex-direction:column;gap:8px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Preguntas detectadas</strong>
          <div class="meta">Total: <span id="total">0</span></div>
        </div>

        <div class="list" id="questionsList">
          <div class="hint">Aquí aparecerán las preguntas detectadas (con opciones). Revisa y, si alguna no tiene la respuesta detectada, edítala.</div>
        </div>

        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button id="startQuiz">Iniciar Quiz</button>
          <button id="saveLocal" class="ghost">Guardar (local)</button>
        </div>
      </div>
    </aside>
  </div>

  <div id="quizModal" style="display:none;margin-top:12px">
    <!-- se reemplaza con la vista de quiz cuando inicies -->
  </div>
</div>

<script>
/*
  Lógica:
  - Usa pdfjsLib (cargado arriba) para abrir el PDF.
  - Para cada página: obtener getAnnotations(); filtrar subtype === 'Underline' (o 'Highlight').
  - Obtener textContent de la página y sus items. Cada item tiene transform[] y str.
  - Convertir quadPoints (anotación) a bbox; comparar contra bounding boxes estimadas de text items; si hay intersección, marcar ese texto como subrayado.
  - Luego, parsear el texto completo (por bloques numerados) para separar pregunta y opciones; para cada opción intentar emparejar el texto con el texto subrayado detectado.
  - Resultado: array de preguntas con opciones y correctas detectadas.
*/

pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.8.162/build/pdf.worker.min.js';

const fileInput = document.getElementById('pdfFile');
const analyzeBtn = document.getElementById('analyzeBtn');
const log = document.getElementById('log');
const preview = document.getElementById('textPreview');
const qList = document.getElementById('questionsList');
const totalSpan = document.getElementById('total');
const startQuizBtn = document.getElementById('startQuiz');
const exportBtn = document.getElementById('exportBtn');
const clearBtn = document.getElementById('clearBtn');
const previewBtn = document.getElementById('previewBtn');
const saveLocalBtn = document.getElementById('saveLocal');

let detectedQuestions = []; // {q, options: [{key,text,correct}], pageInfo...}
let lastExtractedText = '';

function logMsg(s){ log.textContent = s; }

function bboxFromQuadPoints(qp){
  // qp is array of numbers [x1,y1,x2,y2,...]
  // compute minx,miny,maxx,maxy
  const xs = []; const ys=[];
  for(let i=0;i<qp.length;i+=2){ xs.push(qp[i]); ys.push(qp[i+1]); }
  const minx = Math.min(...xs), maxx = Math.max(...xs), miny = Math.min(...ys), maxy = Math.max(...ys);
  return {minx,miny,maxx,maxy};
}

function itemBBoxFromTextItem(item, viewport){
  // item.transform => [a,b,c,d,e,f] where e,f is position in PDF pts.
  // Use transform to map to viewport coords
  // pdf.js has viewport.convertToViewportPoint / convertToViewportRectangle but we don't have page reference here.
  // We'll use transform values:
  const e = item.transform[4], f = item.transform[5];
  // width: item.width (available in newer pdf.js builds) - fall back to measure approx by item.str length * fontSize*0.5
  let width = item.width || (item.str.length * (Math.abs(item.transform[0]) || 6));
  let height = Math.abs(item.transform[3]) || 10;
  // bbox in pdf text coords
  return {minx: e, miny: f - height, maxx: e + width, maxy: f};
}

async function analyzePDF(file){
  logMsg('Cargando PDF...');
  const arrayBuffer = await file.arrayBuffer();
  const loading = pdfjsLib.getDocument({data:arrayBuffer});
  const pdf = await loading.promise;
  logMsg('PDF cargado, páginas: ' + pdf.numPages);
  detectedQuestions = [];
  let fullText = '';

  for(let p=1;p<=pdf.numPages;p++){
    logMsg(`Procesando página ${p} / ${pdf.numPages} ...`);
    const page = await pdf.getPage(p);
    const annotations = await page.getAnnotations();
    const textContent = await page.getTextContent();
    // textContent.items => array of items {str, transform, width, height?}
    const items = textContent.items.map(it=>{
      return {str: it.str, transform: it.transform, width: it.width, raw: it};
    });

    // store text of page
    const pageText = items.map(i=>i.str).join(' ');
    fullText += '\n\n' + pageText;

    // find underline annotations
    const underlines = annotations.filter(a => (a.subtype && a.subtype.toLowerCase()==='underline') || (a.annotationType && a.annotationType===8) );
    // also consider highlights? some apps use highlight for underline; include 'Highlight' subtype optionally
    const highlights = annotations.filter(a => a.subtype && a.subtype.toLowerCase()==='highlight');
    const markup = underlines.concat(highlights);

    // For each markup annotation, get quadPoints (array of numbers)
    const underlinedTexts = []; // strings detected underlined on this page
    for(const ann of markup){
      const qp = ann.quadPoints || ann.quadPointsArray || null;
      if(!qp && ann.rect) {
        // fallback to rect
        // rect: [x1,y1,x2,y2]
      }
      // pdf.js may provide quadPoints as array of numbers when present, or as array of points in some builds
      let quads = [];
      if(Array.isArray(qp) && qp.length>0){
        // sometimes it's an array of objects; normalize to array of arrays of numbers
        if(typeof qp[0] === 'number'){
          // flat array [x1,y1,x2,y2,...] OR multiple quads
          // chunk into 8-number groups (4 points)
          for(let i=0;i<qp.length;i+=8){
            quads.push(qp.slice(i,i+8));
          }
        } else if(Array.isArray(qp[0])){
          quads = qp;
        } else {
          // object forms - ignore for now
        }
      } else if(ann.quadPointsArray && ann.quadPointsArray.length){
        quads = ann.quadPointsArray;
      } else if(ann.rect){
        const r = ann.rect; quads.push([r[0],r[1],r[2],r[1],r[2],r[3],r[0],r[3]]);
      }

      for(const q of quads){
        const bbox = bboxFromQuadPoints(q);
        // find items whose bbox intersects (approx)
        const matched = [];
        for(const it of items){
          const ib = itemBBoxFromTextItem(it);
          // simple intersection test in text coords
          if(!(ib.maxx < bbox.minx || ib.minx > bbox.maxx || ib.maxy < bbox.miny || ib.miny > bbox.maxy)){
            matched.push(it.str);
          }
        }
        if(matched.length) underlinedTexts.push(matched.join(' '));
      }
    }

    // Attach page results to a combined extractor
    page.__underlinedTexts = underlinedTexts;
    page.__rawText = pageText;
    // push to global collector
    // We'll store raw page text and underlined fragments for later mapping
    detectedQuestions.push({pageNumber: p, pageText, underlinedTexts});
  } // end pages loop

  lastExtractedText = fullText.trim();
  preview.value = lastExtractedText;
  logMsg('Extracción completa. Ahora parseando preguntas del texto extraído...');
  // Ahora parseamos el texto global y mapeamos subrayados
  const parsed = parseQuestionsFromText(lastExtractedText, detectedQuestions);
  detectedQuestions = parsed;
  renderDetectedQuestions();
  logMsg('Listo. Revisa las preguntas y pulsa "Iniciar Quiz" cuando quieras.');
  totalSpan.textContent = detectedQuestions.length;
}

// Very simple parser: split by numbered items like "1.-" or "1." and collect until next number.
// Then inside each block, detect options lines starting with a), b), c), d)
function parseQuestionsFromText(fullText, pagesInfo){
  const lines = fullText.replace(/\r\n/g,'\n').split('\n').map(l=>l.trim()).filter(Boolean);
  const text = lines.join('\n');
  // split by number header
  const blocks = [];
  const re = /(^|\n)(\s*\d+\s*[\.\-\)]\s*)/g;
  let indices = [];
  let match;
  while((match=re.exec(text))!==null){
    indices.push(match.index + match[1].length);
  }
  if(indices.length===0){
    // fallback: consider entire text as single block
    blocks.push(text);
  } else {
    for(let i=0;i<indices.length;i++){
      const start = indices[i];
      const end = indices[i+1] || text.length;
      const slice = text.slice(start,end).trim();
      blocks.push(slice);
    }
  }

  const results = [];
  for(const blk of blocks){
    // first line is question beginning
    const linesb = blk.split('\n').map(l=>l.trim()).filter(Boolean);
    if(linesb.length===0) continue;
    // find first option index
    let optStart = linesb.findIndex(l => /^[a-d]\s*[\)\.]/i.test(l));
    // If options inline on same line, split by a) pattern
    let qText = linesb.slice(0, optStart===-1?1:optStart).join(' ');
    qText = qText.replace(/^\d+\s*[\.\-\)]\s*/,'').trim();
    let optLines = optStart===-1 ? [] : linesb.slice(optStart);
    // Try to also split inline options like "a) ... b) ... c) ..."
    if(optLines.length===0){
      const inlineOpts = blk.split(/(?=[a-d]\s*[\)\.]\s)/i).map(s=>s.trim()).filter(Boolean);
      if(inlineOpts.length>1){
        // first piece may contain question
        qText = inlineOpts[0].replace(/^\d+\s*[\.\-\)]\s*/,'').trim();
        optLines = inlineOpts.slice(1);
      }
    }
    const options = [];
    for(const ol of optLines){
      const m = ol.match(/^([a-d])\s*[\)\.]\s*(.*)$/i);
      if(m){ options.push({ key: m[1].toLowerCase(), text: m[2].trim() }); }
      else {
        // append to last option if exists
        if(options.length) options[options.length-1].text += ' ' + ol;
      }
    }

    // Detect which option text intersects underlined fragments collected from pagesInfo
    // strategy: for each option, if any underlined fragment string includes part of option text (or viceversa), mark as correct
    let matchedCorrectKey = null;
    const allUnderlined = pagesInfo.flatMap(p=>p.underlinedTexts || []);
    // normalize
    const normalizedUnderlines = allUnderlined.map(s=>s.replace(/\s+/g,' ').trim().toLowerCase());
    for(const opt of options){
      const nopt = opt.text.replace(/\s+/g,' ').trim().toLowerCase();
      // check contains or partial match
      if(normalizedUnderlines.some(u => u.includes(nopt) || nopt.includes(u) || commonSubstr(u,nopt) >= 6)){
        matchedCorrectKey = opt.key;
        opt.correct = true;
      } else {
        opt.correct = false;
      }
    }
    results.push({ q: qText, options: options, correct: matchedCorrectKey });
  }
  return results;
}

// helper: longest common substring length between two strings (simple)
function commonSubstr(a,b){
  if(!a||!b) return 0;
  let max = 0;
  const A = a, B = b;
  for(let i=0;i<A.length;i++){
    for(let j=0;j<B.length;j++){
      let k=0;
      while(A[i+k] && B[j+k] && A[i+k]===B[j+k]) k++;
      if(k>max) max=k;
    }
  }
  return max;
}

// render detected questions list
function renderDetectedQuestions(){
  qList.innerHTML = '';
  if(detectedQuestions.length===0){
    qList.innerHTML = '<div class="hint">No se detectaron preguntas. ¿El PDF tiene texto seleccionable y subrayados?</div>';
    return;
  }
  detectedQuestions.forEach((q,idx)=>{
    const el = document.createElement('div');
    el.className = 'qitem';
    el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center">
      <strong>${idx+1}. ${escapeHtml(q.q)}</strong>
      <div class="meta">${q.options.length} opciones</div>
    </div>`;
    if(q.options && q.options.length){
      const opts = document.createElement('div');
      opts.className = 'options';
      q.options.forEach(op=>{
        const lab = document.createElement('label');
        lab.className = 'opt ' + (op.correct? 'opt-correct':'' );
        lab.innerHTML = `<div style="width:22px;font-weight:700;color:var(--muted)">${op.key})</div>
                         <div style="flex:1">${escapeHtml(op.text)}</div>`;
        opts.appendChild(lab);
      });
      el.appendChild(opts);
    } else {
      const no = document.createElement('div');
      no.className = 'hint';
      no.textContent = 'Sin opciones detectadas';
      el.appendChild(no);
    }
    qList.appendChild(el);
  });
  totalSpan.textContent = detectedQuestions.length;
}

// Utility escape
function escapeHtml(s){ return (s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

// Start quiz UI (simple)
startQuizBtn.addEventListener('click', ()=>{
  if(detectedQuestions.length===0){ alert('No hay preguntas detectadas. Analiza un PDF primero.'); return; }
  openQuizMode(detectedQuestions);
});

// Export JSON
exportBtn.addEventListener('click', ()=>{
  const data = JSON.stringify(detectedQuestions, null, 2);
  const blob = new Blob([data], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'preguntas_detectadas.json'; a.click(); URL.revokeObjectURL(url);
});

// Clear
clearBtn.addEventListener('click', ()=>{ if(confirm('Borrar todo lo detectado?')){ detectedQuestions = []; renderDetectedQuestions(); preview.value=''; logMsg('Borrado.'); totalSpan.textContent='0'; } });

// Save to localStorage
saveLocalBtn.addEventListener('click', ()=>{
  localStorage.setItem('pdf_quiz_detected', JSON.stringify(detectedQuestions));
  flash('Guardado localmente');
});

// preview text area
previewBtn.addEventListener('click', ()=>{ if(!lastExtractedText) { flash('No hay texto extraído'); return;} alert(lastExtractedText.slice(0,2000)); });

// Analyze button
analyzeBtn.addEventListener('click', async ()=>{
  const f = fileInput.files[0];
  if(!f){ alert('Selecciona un archivo PDF primero'); return; }
  try{ await analyzePDF(f); } catch(err){ console.error(err); alert('Error analizando PDF: ' + err.message); logMsg('Error: ' + err.message); }
});

// Simple modal quiz
function openQuizMode(qs){
  // replace page content with a simple quiz interface
  const container = document.getElementById('quizModal');
  container.style.display = 'block';
  container.innerHTML = '';
  let idx = 0;
  let score = 0;
  const wrapper = document.createElement('div');
  wrapper.className = 'card';
  wrapper.style.marginTop='12px';
  const header = document.createElement('div');
  header.style.display='flex'; header.style.justifyContent='space-between'; header.style.alignItems='center';
  header.innerHTML = `<strong>Quiz (modo inmediato)</strong><div class="meta">Pregunta <span id="qidx">1</span> / ${qs.length} — Puntaje: <span id="qscore">0</span></div>`;
  wrapper.appendChild(header);

  const qArea = document.createElement('div'); qArea.style.marginTop='12px';
  wrapper.appendChild(qArea);

  const nav = document.createElement('div'); nav.style.display='flex'; nav.style.gap='8px'; nav.style.marginTop='12px';
  const prev = document.createElement('button'); prev.textContent='Anterior'; prev.className='ghost';
  const next = document.createElement('button'); next.textContent='Siguiente'; next.className='ghost';
  const done = document.createElement('button'); done.textContent='Terminar'; done.className='ghost';
  nav.appendChild(prev); nav.appendChild(next); nav.appendChild(done);
  wrapper.appendChild(nav);
  container.appendChild(wrapper);

  function renderQuestion(i){
    const q = qs[i];
    qArea.innerHTML = `<div style="font-weight:700;margin-bottom:8px">${i+1}. ${escapeHtml(q.q)}</div>`;
    if(!q.options || q.options.length===0){
      qArea.innerHTML += `<div class="hint">Sin opciones detectadas.</div>`;
      return;
    }
    const opts = document.createElement('div'); opts.className='options';
    q.options.forEach(op=>{
      const id = `opt_${i}_${op.key}`;
      const lab = document.createElement('label');
      lab.className = 'opt';
      lab.innerHTML = `<input type="radio" name="opt_${i}" id="${id}" value="${op.key}" style="width:18px;height:18px;margin-right:8px">
                       <div style="flex:1">${escapeHtml(op.text)}</div>`;
      lab.querySelector('input').addEventListener('change', ()=>{
        // immediate feedback
        const chosen = op.key;
        const correct = q.options.find(o=>o.correct)?.key || q.correct;
        if(correct && chosen === correct){
          lab.classList.add('opt-correct'); score++;
          flash('✔ Correcto',800,true);
        } else {
          lab.classList.add('opt-wrong');
          // highlight correct one
          const corrKey = correct;
          if(corrKey){
            // find sibling label with that option
            const labels = opts.querySelectorAll('label.opt');
            labels.forEach(lbl=>{
              if(lbl.textContent.trim().startsWith(corrKey + ')') || lbl.textContent.includes(corrKey + ')')){
                lbl.classList.add('opt-correct');
              }
            });
          }
          flash('✖ Incorrecto',1200,false);
        }
        // disable all radios for this question
        opts.querySelectorAll('input').forEach(inp=>inp.disabled=true);
        // update header score
        document.getElementById('qscore').textContent = score;
      });
      opts.appendChild(lab);
    });
    qArea.appendChild(opts);
    document.getElementById('qidx').textContent = i+1;
  }

  prev.onclick = ()=>{ if(idx>0) { idx--; renderQuestion(idx); } };
  next.onclick = ()=>{ if(idx<qs.length-1){ idx++; renderQuestion(idx);} };
  done.onclick = ()=>{ if(confirm('Terminar quiz?')){ container.innerHTML = `<div class="card"><strong>Resultados</strong><div style="margin-top:8px">Puntaje: ${score} / ${qs.length}</div></div>`; } };

  renderQuestion(idx);
}

// small visual toast
function flash(text, ms=900, ok=true){
  const el = document.createElement('div');
  el.textContent = text;
  el.style.position='fixed'; el.style.left='50%'; el.style.transform='translateX(-50%)';
  el.style.bottom='30px'; el.style.padding='10px 14px'; el.style.borderRadius='10px';
  el.style.background = ok? 'rgba(6,182,212,0.12)' : 'rgba(255,255,255,0.03)';
  el.style.color = '#e6f7f8'; el.style.border='1px solid rgba(255,255,255,0.04)';
  document.body.appendChild(el);
  setTimeout(()=> el.remove(), ms);
}

</script>
</body>
</html>
